package projeto.maispop.usuario;

import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

import projeto.maispop.excecoes.EntradaException;

/**
 * Classe <code>PostagemFormat</code> constituida como uma <i>Singloton</i>. Tem
 * a funcao de oferecer um auxilio para a classe <i>Postagem</i> para que seja
 * feita todas as formatacoes necessarias na mesma. Levando em consideracoes as
 * exigencias dos casos de aceitacao do projeto de LP2: +pop.
 *
 * 
 * @author Gerson Sales
 * @author Adson Cesar
 * @see Postagem
 * @version 0.3
 *
 */
public class PostagemFormat {

	/**
	 * Variavel estatica(pertence a classe) que tem a responsabilidade de
	 * armazenar a instacia de <code>PostagemFormat</code>.
	 */
	public static PostagemFormat instancia;

	/**
	 * Construtor da classe <code>PostagemFormat</code> que tem a visibilidade
	 * definida como <i>private</i>, obedecendo um dos principios de uma
	 * <i>Singleton</i>, para que nenhuma outra classe possa criar instancias de
	 * <code>PostagemFormat</code>.
	 */
	private PostagemFormat() {
	}

	/**
	 * Metodo <i>getInstancia</i> responsavel por verificar se o atributo <i>instancia</i>
	 * ja teve valor definido, caso nao, cria uma nova instancia de <code>PostagemFormat</code>, caso sim,
	 * retorna o valor da varivel em questao.
	 * @return PostagemFormat. Referencia unica da propria classe.
	 */
	public static PostagemFormat getInstancia() {
		if (instancia == null) {
			instancia = new PostagemFormat();
		}

		return instancia;
	}
	
	/**
	 * Metodo <i>getHashTag</i> responsavel por receber um texto como parametro e extrair dele apenas
	 * palavras consideradas como <i>hashtags</i>.
	 * @param texto. String usada para extrair as <i>hashtags</i>
	 * @return String. Nova String contendo apenas as <i>hashtags</i> encontradas.
	 * @throws EntradaException. Caso o algoritmo encontre uma palavra que nao contenha hashtag apos ja ter encontrado a primeira.
	 * <br>
	 * <b>Exemplo de erro</b>:
	 * "texto. #primeiraHashTag SegundaHashTag #TerceiraHashTag".
	 */
	public String getHashTag(String texto) throws EntradaException {
		if (!(texto.contains("#"))) {
			return "";
		}

		texto = texto.substring(texto.indexOf("#"), texto.length());
		String[] hashTags = texto.split(" ");
		for (String palavra : hashTags) {
			if (!(palavra.contains("#"))) {
				throw new EntradaException(
						"As hashtags devem comecar com '#'. Erro na hashtag: '"
								+ palavra + "'.");
			}
		}
		return texto.replace(" ", ",");
	}

	

	/**
	 * Metodo <i>getMidia</i> responsavel por receber um texto como parametro e utilizar-se 
	 * de um algoritmo para realizar uma busca em tal texto a procura de entidades de <i>midias</i>.
	 * Retornando uma lista de <i>String</i> contendo todos as midias encontradas e devidamente formatadas.
	 * <br>
	 * <b>Exemplo de uso</b>: class.getMidia("Texto referente ao exemplo <audio>midia.mp3</audio>");
	 * <p><br>retorno</i>Lista: ["$arquivo_audio:midia.mp3"]
	 * @param texto
	 * @return
	 */
	public List<String> getMidia(String texto) {
		String marcacao = "";
		texto = texto.replace(">", "> ");
		texto = texto.replace("<", " <");

		String[] textoSplit = texto.split(" ");
		List<String> midia = new ArrayList<>();
		String caminhoMidia = "$arquivo_";

		boolean adicionaPalavra = false;
		for (String palavra : textoSplit) {
			if (palavra.equals(""))
				continue;// .split() nao remove todos os espacacos.

			if (palavra.equals("<audio>") || palavra.equals("<imagem>")) {
				caminhoMidia = caminhoMidia
						+ palavra.substring(1, palavra.length() - 1) + ":";
				marcacao = palavra;

				adicionaPalavra = true;
				continue;
			}

			if (palavra.equals(marcacao.replace("<", "</"))) {
				midia.add(caminhoMidia);
				caminhoMidia = "$arquivo_";

				adicionaPalavra = false;
				continue;
			}

			if (adicionaPalavra) {
				caminhoMidia = caminhoMidia + palavra;
			}
		}
		return midia;
	}

	public String getMensagem(String texto) throws EntradaException {
		int indexAudio = texto.indexOf("<audio>");
		texto = indexAudio == -1 ? texto : texto.substring(0, indexAudio);

		int indexImagem = texto.indexOf("<imagem>");
		texto = indexImagem == -1 ? texto : texto.substring(0, indexImagem);

		int indexHashTag = texto.indexOf("#");
		texto = indexHashTag == -1 ? texto : texto.substring(0, indexHashTag);

		if (texto.length() > 200) {
			throw new EntradaException(
					"O limite maximo da mensagem sao 200 caracteres.");
		}

		return removeUltimoEspaco(texto);
	}

	private String removeUltimoEspaco(String texto) {
		if (texto.charAt(texto.length() - 1) != ' ') {
			return texto;
		}

		texto = texto.substring(0, texto.length() - 1);
		return removeUltimoEspaco(texto);
	}

	public String getMensagemMidia(String texto) throws EntradaException {
		int indexHashTag = texto.indexOf("#");
		texto = indexHashTag == -1 ? texto : texto.substring(0, indexHashTag);
		if (texto.length() > 200) {
			throw new EntradaException(
					"O limite maximo da mensagem sao 200 caracteres.");
		}

		return removeUltimoEspaco(texto);

	}

	public String formatData(String dataPostagem) {
		DateTimeFormatter padrao = DateTimeFormatter
				.ofPattern("dd/MM/yyyy HH:mm:ss");
		DateTimeFormatter novoPadrao = DateTimeFormatter
				.ofPattern("yyyy-MM-dd HH:mm:ss");
		String novaData = LocalDateTime.parse(dataPostagem, padrao).format(
				novoPadrao);
		return novaData;
	}

}
